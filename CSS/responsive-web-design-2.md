## 역사

### 고정폭 디자인

웹이 처음 대중화되었던 1990년대 초, 대부분의 모니터는 640x480 픽셀이었으므로 너비가 640px인 웹 페이지를 디자인하는 것이 최적의 선택이었다. 그러나 시간이 흐를수록 화면은 점점 더 커지고, 그에 따라 웹 디자인의 기준을 새로 정해야 했다. 이를 해결하기 위해 개발자와 디자이너들은 보다 유연한 레이아웃을 찾기 시작했다.

### 유동적 레이아웃

레이아웃에 고정 너비를 사용하는 대신 열 너비에 백분율을 사용하였다. 고정폭 디자인보다 훨씬 유연하지만, 극단적인 상황에서는 좋지 않은 사용자 경험을 제공한다. 와이드 스크린에서는 레이아웃이 쭉 늘어나고, 모바일 화면에서는 찌그러져 보이기 때문.

`min-width`와 `max-width` 을 사용하면 이러한 문제를 완화할 수 있지만, 최소 너비보다 작거나 최대 너비보다 큰 경우 결국 동일한 문제가 발생하게 된다. 와이드 스크린에서는 사용하지 않는 공간이 낭비될 것이며 좁은 화면에서는 스크롤바가 생길 것이다.

> TIP : %와 vw/vh의 차이점?
> 

`vw`와 `vh`는 기준이 `viewport`이다. 즉, 현재 보여지고 있는 화면 크기를 기준으로 하여 상대적 크기를 반환한다. 100vw, 100vh가 각각 전체 화면의 기준이 된다.

`백분율`은 화면 전체가 아닌 `부모 요소`의 길이를 기준으로 하여 상대적 크기를 반환한다.

### 작은 화면, 계속되는 이슈

휴대전화의 등장으로 모바일 화면에서의 웹 디자인이 이슈로 떠올랐다. 기존의 데스크톱 화면과 새로운 모바일 화면 전부에서 디자인을 아름답게 보이게 하려면 어떻게 해야 할까?

- 별도의 하위 도메인

괜찮은 생각이지만 각각 별도의 코드와 디자인을 유지보수해야 한다. 그리고 화면이 두 종류만 있는 것도 아니다. 태블릿은 어떻게 하려고?

- 적응형 레이아웃

`CSS 미디어 쿼리`와 `고정폭 레이아웃`의 매시업. 여러개의 하위 도메인 대신, 여러개의 고정폭 레이아웃을 가진 하나의 단일 사이트를 만든다. 나쁘지 않은 해결책이지만, 여전히 초과 공간 문제가 지속되었다.

### 반응형 웹 디자인

`CSS 미디어 쿼리`와 `유동적 레이아웃`의 매시업. 

- 유체 그리드
- 유체 미디어
- 미디어 쿼리

## 뷰포트를 위한 메타 요소

> 이 태그와 요소를 사용함으로써, **웹 페이지는 “반응”할 준비가 된다.**
> 

모바일 브라우저는 웹 사이트를 처리할 때 980px을 기본으로 알고 있기 때문에 먼저 980px을 적용하고 렌더링된 웹 페이지를 모바일 화면의 실제 너비로 축소한다.

이러한 크기 조정을 수행하지 않도록 웹 페이지의 `meta` 요소를 사용하여 브라우저에 먼저 알려 줄 수 있다. 

```html
<meta name="viewport" content="width=device-width, initial-scale=1">
```

- `width=device-width` : 웹 사이트의 너비가 (980px 대신) 장치의 너비와 같다고 가정하도록 브라우저에 지시한다. divice-width는 100% 스케일에서 CSS 픽셀들로 계산된 화면의 폭을 의미함.
- `initial-scale=1` : 웹 페이지가 처음 로딩될 때 줌 레벨을 조정- 즉 브라우저에게 스케일링을 얼마나 많이/적게 해야 할지 알려줌. 1일 시 CSS 픽셀과 기기종속적 픽셀이 1:1관계를 이룬다.

## 미디어 쿼리

> 쿼리(Query)란?
> 

DB에게 특정한 데이터를 보여달라는 클라이언트(유저)의 요청.

그렇다면 우리는 미디어 쿼리가 무엇인지 대충 유추할 수 있다. CSS에서 원하는 미디어만을 표시한다는 느낌이다.

웹 페이지를 인쇄할 때, 일반 화면과는 달리 배경색을 회색으로 지정하고 싶을 때 CSS에서 `미디어 유형`을 사용하여 지정할 수 있다.

```css
body {
  color: black;
  background-color: grey;
}

@media print {
  body {
    background-color: transparent;
  }
}
```

별도의 스타일시트를 만들고 html에서 media 속성을 사용할 수도 있다. 위 코드와 동일하다. 

```html
<link rel="stylesheet" href="global.css">
<link rel="stylesheet" href="print.css" media="print">
```

미디어 유형을 지정하지 않으면 자동으로 `all`이 들어간다. 밑의 CSS, HTML은 전부 동일하다.

```css
body {
  color: black;
  background-color: white;
}

/* 위 코드와 같다 */
@media all {
   body {
     color: black;
     background-color: white;
   }
}
```

```html
<link rel="stylesheet" href="global.css">

// 위 코드와 같다
<link rel="stylesheet" href="global.css" media="all">
```

### 쿼리 조건

미디어 유형에 `조건`을 추가할 수 있는데, 이것이 바로 `미디어 쿼리`이다. 기본적으로 다음 구문을 따른다.

```css
@media type and (feature)
```

```html
<link rel="stylesheet" href="specific.css" media="type and (feature)">
```

> Tip : 다른 미디어 **유형**에 대해 별도의 스타일시트를 적용하는 것은 괜찮지만 모든 미디어 **쿼리**에 대해 별도의 스타일시트를 사용하는 것은 좋은 생각이 아니다: 대신 `at-rules`를 사용하자.
> 

## 뷰포트 크기에 따라 스타일 조정

브라우저 창이 특정 너비보다 넓거나 좁을 때 스타일을 적용해보자.

```css
@media (min-width: 400px) {
  // Styles for viewports wider than 400 pixels.
}

@media (max-width: 400px) {
  // Styles for viewports narrower than 400 pixels.
}
```

콘텐츠가 대부분 이미지 기반인 경우 픽셀 단위가 적합하겠지만, 텍스트 기반인 경우 텍스트 크기를 기반으로 하는 상대 단위인 `em`을 사용하는 것이 적합할 수도 있다.

```css
@media (min-width: 50em) and (max-width: 60em) {
  // Styles for viewports wider than 50em and narrower than 60em.
}
```

## 중단점

미디어 조건이 참이 되는 지점을 `중단점`이라고 한다. 하드웨어 장치 크기보다는, **콘텐츠**를 기반으로 `중단점`을 선택하는 것이 좋다.

예를 들어, 텍스트 줄이 보기 불편할 정도로 길어지는 것을 막기 위해 본문이 50em을 넘어가면 해당 지점부터 열을 두 개로 늘려 보기 편하게 할 수 있다.

```css
@media (min-width: 50em) {
  article {
    column-count: 2;
  }
}
```

여러 요소를 and로 조합하여 미디어 쿼리를 적용할 수 있다. “스크롤 없이 맨 처음으로 볼 수 있는 부분”의 인터페이스 컨텐츠를 최적화 해 보자. 

사용자가 와이드 스크린을 사용하는 경우, 앞의 예시는 살짝 문제점이 있다. 컨텐츠의 양이 적은 경우 첫 번째 열은 컨텐츠가 가득 차지만 두 번째 열은 얼마 안 되는 컨텐츠만 남아 전체적으로 보기 흉할 수 있기 때문이다. 이를 해결하기 위해 `width`뿐만 아니라 `height`도 미디어 쿼리 조건으로 추가해주었다.

```css
@media (min-width: 50em) and (min-height: 60em) {
  article {
    column-count: 2;
  }
}
```

미디어 쿼리는 너비나 높이를 넘어 접근성 기능, 테마 색상에 대한 사용자 기본 설정 등에 엑세스 할 수 있다… 무한 가능성을 지닌 기능이다!